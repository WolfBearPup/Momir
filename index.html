from flask import Flask, request, jsonify
from escpos.printer import Usb
from PIL import Image, ImageOps
import requests, io, time

# ---- EDIT THESE ----
VENDOR_ID  = 0x0000  # e.g. 0x04b8
PRODUCT_ID = 0x0000  # e.g. 0x0202

# 58mm printers are commonly 384 dots wide at 203dpi
TARGET_WIDTH = 384

app = Flask(__name__)

def get_printer():
    # Most USB ESC/POS printers work with just vendor/product.
    # python-escpos docs show this pattern. :contentReference[oaicite:2]{index=2}
    return Usb(VENDOR_ID, PRODUCT_ID, timeout=0)

def scryfall_random_creature(cmc: int):
    # Simple, stable query. (You can add more filters later.)
    q = f"type:creature game:paper lang:en mv={cmc}"
    url = "https://api.scryfall.com/cards/random"
    r = requests.get(url, params={"format": "json", "q": q}, timeout=20)

    if r.status_code != 200:
        # Scryfall returns an error object when no match exists.
        try:
            return None, r.json().get("details", "No matching creatures.")
        except Exception:
            return None, "No matching creatures."
    return r.json(), None

def pick_image_url(card: dict):
    # Handle double-faced cards too
    if "image_uris" in card and card["image_uris"].get("border_crop"):
        return card["image_uris"]["border_crop"]
    if "card_faces" in card:
        for face in card["card_faces"]:
            if face.get("image_uris", {}).get("border_crop"):
                return face["image_uris"]["border_crop"]
    return None

def prepare_image_for_58mm(img: Image.Image) -> Image.Image:
    img = img.convert("RGB")
    # resize to TARGET_WIDTH maintaining aspect
    w, h = img.size
    new_h = max(1, int(h * (TARGET_WIDTH / float(w))))
    img = img.resize((TARGET_WIDTH, new_h))

    # grayscale + autocontrast + convert to 1-bit (dither)
    img = ImageOps.grayscale(img)
    img = ImageOps.autocontrast(img)
    img = img.convert("1")
    return img

def print_card(card: dict):
    p = get_printer()

    name = card.get("name", "Unknown")
    mv = card.get("mana_value", card.get("cmc", "?"))
    type_line = card.get("type_line", "")
    oracle = card.get("oracle_text", "")
    scry = card.get("scryfall_uri", "")

    # Print a header
    p.set(align="center", bold=True, width=2, height=2)
    p.text(f"{name}\n")
    p.set(align="left", bold=False, width=1, height=1)
    p.text(f"MV: {mv}\n{type_line}\n\n")

    if oracle:
        p.text(oracle + "\n\n")

    # Try printing the image (optional)
    img_url = pick_image_url(card)
    if img_url:
        r = requests.get(img_url, timeout=30)
        r.raise_for_status()
        img = Image.open(io.BytesIO(r.content))
        img = prepare_image_for_58mm(img)
        p.image(img)
        p.text("\n")

    # Optional QR to full card online (fast + useful)
    if scry:
        p.qr(scry, size=4)
        p.text("\n")

    p.text("\n\n")
    try:
        p.close()
    except Exception:
        pass

@app.get("/health")
def health():
    return jsonify({"ok": True, "ts": int(time.time())})

@app.post("/summon")
def summon():
    payload = request.get_json(force=True) or {}
    cmc = int(payload.get("cmc", -1))
    do_print = bool(payload.get("print", True))

    if cmc < 0:
        return jsonify({"ok": False, "error": "Missing cmc"}), 400

    card, err = scryfall_random_creature(cmc)
    if not card:
        return jsonify({"ok": False, "error": err or "No matching creatures", "cmc": cmc}), 404

    if do_print:
        try:
            print_card(card)
        except Exception as e:
            return jsonify({"ok": False, "error": f"Print failed: {e}", "card": card}), 500

    return jsonify({"ok": True, "card": card})

# If you want the phone to pick the card, POST the full card JSON here:
@app.post("/printCard")
def printcard():
    payload = request.get_json(force=True) or {}
    card = payload.get("card")
    if not isinstance(card, dict):
        return jsonify({"ok": False, "error": "Missing card object"}), 400
    try:
        print_card(card)
    except Exception as e:
        return jsonify({"ok": False, "error": f"Print failed: {e}"}), 500
    return jsonify({"ok": True})

if __name__ == "__main__":
    # Listen on local network
    app.run(host="0.0.0.0", port=8080)
